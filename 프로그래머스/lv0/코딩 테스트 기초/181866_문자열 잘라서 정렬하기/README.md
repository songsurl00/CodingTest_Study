## 문제 설명

문자열 `myString`이 주어집니다. `"x"`를 기준으로 해당 문자열을 잘라내 배열을 만든 후  
사전순으로 정렬한 배열을 return 하는 `solution` 함수를 완성해주세요.

단, 빈 문자열은 반환할 배열에 넣지 않습니다.

## 제한사항

- 1 ≤ `myString` ≤ 100,000
  - `myString`은 알파벳 소문자로 이루어진 문자열입니다.

## 입출력 예

| myString          | result                       |
| ----------------- | ---------------------------- |
| `"axbxcxdx"`      | `["a", "b", "c", "d"]`       |
| `"dxccxbbbxaaaa"` | `["aaaa", "bbb", "cc", "d"]` |

## 입출력 예 설명

### 입출력 예 #1

- `myString`을 `"x"`를 기준으로 자른 배열은 `["a", "b", "c", "d"]`이며,  
  이 배열은 이미 사전순으로 정렬된 상태입니다.  
  따라서 `["a", "b", "c", "d"]`를 return 합니다.

### 입출력 예 #2

- `myString`을 `"x"`를 기준으로 자른 배열은 `["d", "cc", "bbb", "aaaa"]`이며,  
  이 배열을 사전순으로 정렬하면 `["aaaa", "bbb", "cc", "d"]`가 됩니다.  
  따라서 해당 배열을 return 합니다.

## 내 풀이

배열 순회를 반복하고 정렬 연산도 하다보니 시간 복잡도가 걱정되었다.
이 문제는 시간복잡도를 고려하지 않아도 괜찮지만 나중에는 시간복잡도를 꼭 생각해보자.
이번에 알게 된 사실은 js의 sort는 O(NlogN) 의 시간복잡도를 가진다는 사실이다.

```js
function solution(myString) {
  return myString
    .split('x')
    .filter((s) => s)
    .sort();
}
```

## 다른 풀이

확실히 정규표현식을 이용하면 문자열에서 특정 문자를 찾는게 더 간단해보인다. 정규표현식을 꼭 공부하자.

```js
const solution = (s) => s.match(/[^x]+/g).sort();
```
