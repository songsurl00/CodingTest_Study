## 문제 설명

정수 배열 `arr`가 주어집니다.  
`arr`의 각 원소에 대해:

- 값이 50보다 크거나 같은 짝수이면 → 2로 나눕니다.
- 50보다 작은 홀수이면 → 2를 곱하고 다시 1을 더합니다.

이러한 작업을 `x`번 반복한 결과 배열을 `arr(x)`라고 했을 때,  
`arr(x) = arr(x + 1)`인 `x`가 항상 존재합니다.  
이때의 가장 작은 `x`를 return하는 `solution` 함수를 완성해주세요.

※ 두 배열의 같음(`=`)이란 길이가 같고 같은 인덱스의 원소들이 모두 동일함을 의미합니다.

## 제한사항

- 1 ≤ `arr`의 길이 ≤ 1,000,000
- 1 ≤ `arr`의 원소의 값 ≤ 100

## 입출력 예

| arr                    | result |
| ---------------------- | ------ |
| [1, 2, 3, 100, 99, 98] | 5      |

## 입출력 예 설명

### 예제 #1

- `arr`의 변화 과정:

| 반복 횟수 | arr                     |
| --------- | ----------------------- |
| 0         | [1, 2, 3, 100, 99, 98]  |
| 1         | [3, 2, 7, 50, 99, 49]   |
| 2         | [7, 2, 15, 25, 99, 99]  |
| 3         | [15, 2, 31, 51, 99, 99] |
| 4         | [31, 2, 63, 51, 99, 99] |
| 5         | [63, 2, 63, 51, 99, 99] |
| 6         | [63, 2, 63, 51, 99, 99] |

- 5회 반복 이후부터 변화가 없으므로 결과는 `5`

## 내 풀이

```js
function solution(arr) {
  let x = 0;

  while (true) {
    let prev = [...arr];
    arr = arr.map((n) => {
      if (n >= 50 && n % 2 === 0) return n / 2;
      if (n < 50 && n % 2 === 1) return n * 2 + 1;
      return n;
    });

    if (arr.every((n, index) => n === prev[index])) break;
    x++;
  }

  return x;
}
```

## 다른 풀이

```js
function solution(arr) {
  var answer = 0;
  let before = [-1];

  while (!arr.every((e, idx) => e == before[idx])) {
    before = [...arr];

    arr = arr.map((e) => {
      if ((e >= 50) & (e % 2 == 0)) return e / 2;
      if ((e < 50) & (e % 2 != 0)) return e * 2 + 1;
      return e;
    });
    answer++;
  }
  return answer - 1;
}
```
