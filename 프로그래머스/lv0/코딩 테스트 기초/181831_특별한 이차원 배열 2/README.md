## 문제 설명

n x n 크기의 이차원 배열 `arr`이 매개변수로 주어질 때,  
`arr`이 다음을 만족하면 1을, 아니면 0을 `return` 하는 `solution` 함수를 작성해 주세요.

> 0 ≤ i, j < n인 정수 i, j에 대해  
> `arr[i][j] == arr[j][i]`

## 제한사항

- 1 ≤ `arr`의 길이 = `arr`의 원소의 길이 ≤ 100
- 1 ≤ `arr`의 원소 ≤ 1,000
- 모든 `arr`의 원소는 정수입니다.

## 입력값 예

| arr                                                                                | result |
| ---------------------------------------------------------------------------------- | ------ |
| `[[5, 192, 33], [192, 72, 95], [33, 95, 999]]`                                     | `1`    |
| `[[19, 498, 258, 587], [63, 9, 7, 754], [258, 7, 1000, 723], [587, 754, 723, 81]]` | `0`    |

## 입력값 예 설명

### 입력값 예 #1

예제 1번에서 조건이 잘 보이도록 표로 정리하면 다음과 같습니다:

| i   | j   | arr[i][j] | arr[j][i] |
| --- | --- | --------- | --------- |
| 0   | 0   | 5         | 5         |
| 0   | 1   | 192       | 192       |
| 0   | 2   | 33        | 33        |
| 1   | 0   | 192       | 192       |
| 1   | 1   | 72        | 72        |
| 1   | 2   | 95        | 95        |
| 2   | 0   | 33        | 33        |
| 2   | 1   | 95        | 95        |
| 2   | 2   | 999       | 999       |

조건을 만족하므로 `1`을 return 합니다.

### 입력값 예 #2

예제 2번에서 `arr[0][1] = 498`, `arr[1][0] = 63` 이므로  
`arr[0][1] != arr[1][0]` → 조건 불만족 → `0` return

## 내 풀이

```js
function solution(n) {
  const arr1 = Array.from({ length: n }, () => []);

  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      i === j ? arr1[i].push(1) : arr1[i].push(0);
    }
  }
  return arr1;
}
```

## 다른 풀이

for문을 사용하지 않고 every를 사용해서 비교했다.

```js
function solution(arr) {
  return arr.every((r, i) => r.every((_, j) => arr[i][j] === arr[j][i]))
    ? 1
    : 0;
}
```
